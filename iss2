Perfect üëç ‚Äî based on your database schema and your goal:

Each restaurant owner (in M_S_USERS) can have multiple restaurants (M_D_RESTAURANT.userid = M_S_USERS.userid).

Each order (M_D_ORDERS.restaurant_id) belongs to one restaurant.

So, when an owner logs in, they should see only the orders from their restaurants.


We‚Äôll make 3 clean updates:


---

‚úÖ 1Ô∏è‚É£ Backend ‚Äî OrderServlet

We‚Äôll get the logged-in user from the session and send only their restaurant orders.

@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String action = request.getParameter("action");
    response.setContentType("application/json");
    response.setCharacterEncoding("UTF-8");

    if ("incomingOrders".equals(action)) {
        HttpSession session = request.getSession(false);
        if (session == null || session.getAttribute("user") == null) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("{\"error\":\"Not authenticated\"}");
            return;
        }

        User loggedUser = (User) session.getAttribute("user");
        int ownerId = loggedUser.getUserid();

        try {
            List<Order> orders = orderDao.getIncomingOrdersByOwner(ownerId);  // ‚úÖ owner-specific orders
            Gson gson = new Gson();
            response.getWriter().write(gson.toJson(orders));
        } catch (Exception e) {
            e.printStackTrace();
            response.setStatus(500);
            response.getWriter().write("{\"error\":\"Failed to fetch orders\"}");
        }
    }
}


---

‚úÖ 2Ô∏è‚É£ DAO ‚Äî OrderDAO.java

We‚Äôll fetch only orders belonging to restaurants owned by the logged-in user and include the restaurant name.

public List<Order> getIncomingOrdersByOwner(int ownerId) throws SQLException {
    String sql = "SELECT o.order_id, o.userid, o.restaurant_id, r.name AS restaurant_name, " +
                 "u.name AS customer_name, o.total_amount, o.status, o.order_date " +
                 "FROM food.M_D_ORDERS o " +
                 "JOIN food.M_S_USERS u ON o.userid = u.userid " +
                 "JOIN food.M_D_RESTAURANT r ON o.restaurant_id = r.restaurant_id " +
                 "WHERE r.userid = ? AND o.status != 'GIVEN_TO_DELIVERY' AND o.is_deleted = 0 " +
                 "ORDER BY o.order_date DESC";

    List<Order> orders = new ArrayList<>();
    try (Connection con = DBConnection.getConnection();
         PreparedStatement ps = con.prepareStatement(sql)) {

        ps.setInt(1, ownerId);

        try (ResultSet rs = ps.executeQuery()) {
            while (rs.next()) {
                Order order = new Order();
                order.setOrderId(rs.getInt("order_id"));
                order.setCustomerName(rs.getString("customer_name"));
                order.setRestaurantName(rs.getString("restaurant_name")); // ‚úÖ new field
                order.setTotalAmount(rs.getDouble("total_amount"));
                order.setStatus(rs.getString("status"));
                order.setOrderDate(rs.getTimestamp("order_date").toString());
                order.setItemss(getOrderItems(order.getOrderId()));

                orders.add(order);
            }
        }
    }
    return orders;
}

üß† Make sure your Order model has a new field:

private String restaurantName;
public String getRestaurantName() { return restaurantName; }
public void setRestaurantName(String restaurantName) { this.restaurantName = restaurantName; }


---

‚úÖ 3Ô∏è‚É£ Frontend ‚Äî loadIncomingOrders()

Add Restaurant Name column and populate it.

function loadIncomingOrders() {
  $("#mainContent").html(`
    <div id="incomingOrdersContainer" class="p-6">
      <h2 class="text-3xl font-bold text-orange-400 mb-6">Incoming Orders</h2>
      <table id="incomingOrdersTable" class="display w-full">
        <thead>
          <tr>
            <th>Order ID</th>
            <th>Restaurant Name</th> <!-- ‚úÖ Added -->
            <th>Customer Name</th>
            <th>Items</th>
            <th>Total Amount</th>
            <th>Status</th>
            <th>Order Date</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  `);

  $.ajax({
    url: "http://localhost:8080/BiteBudddy/OrderServlet",
    method: "GET",
    data: { action: "incomingOrders" },
    dataType: "json",
    success: function (res) {
      populateOrdersTable(res);
    },
    error: function (xhr) {
      if (xhr.status === 401) {
        Swal.fire("Session Expired", "Please login again.", "warning").then(() => {
          window.location.href = "login.html";
        });
      } else {
        Swal.fire("Error", "Failed to load incoming orders.", "error");
      }
    },
  });
}

function populateOrdersTable(orders) {
  if (incomingOrdersTable) {
    incomingOrdersTable.destroy();
    $("#incomingOrdersTable tbody").empty();
  }

  orders.forEach(order => {
    const items = order.itemss.map(i => `${i.itemName} x${i.quantity}`).join("<br>");
    const statusOptions = ["PLACED", "PREPARING", "PACKING", "GIVEN_TO_DELIVERY"];
    let statusDropdown = `<select class="orderStatus text-black rounded px-2 py-1" data-orderid="${order.orderId}">`;
    statusOptions.forEach(s => {
      const selected = s === order.status ? "selected" : "";
      statusDropdown += `<option value="${s}" ${selected}>${s}</option>`;
    });
    statusDropdown += "</select>";

    const row = `
      <tr>
        <td>${order.orderId}</td>
        <td>${order.restaurantName}</td> <!-- ‚úÖ Added -->
        <td>${order.customerName}</td>
        <td>${items}</td>
        <td>‚Çπ${order.totalAmount.toFixed(2)}</td>
        <td>${order.status}</td>
        <td>${order.orderDate}</td>
        <td>${statusDropdown}</td>
      </tr>
    `;

    $("#incomingOrdersTable tbody").append(row);
  });

  incomingOrdersTable = $("#incomingOrdersTable").DataTable({
    pageLength: 5
  });
}


---

‚úÖ Summary:

Only owner‚Äôs restaurant orders are fetched (WHERE r.userid = ?).

Added restaurantName column both backend & frontend.

Existing features (status update, filtering) unaffected.


Would you like me to include the backend update for status update (order status change) to ensure it only affects the owner‚Äôs restaurant orders too?