package com.dataloader;

import com.dataloader.DatabaseHelper.ColumnInfo;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.sql.*;
import java.util.*;

public class ExcelProcessor {

	private DatabaseHelper dbHelper;
	private JsonObject tableConfig;
	private String tableName;
	private String objectName;
	private String excelFilePath;
	private String sheetName;
	private int headerRowIndex;
	private boolean createTableIfNotExists;
	private boolean truncateBeforeInsert;
	private String insertMode;
	private List<String> uniqueKeys;
	private String updateStrategy;
	private List<DatabaseHelper.ColumnInfo> columns;

	public ExcelProcessor(DatabaseHelper dbHelper, JsonObject tableConfig) {
		this.dbHelper = dbHelper;
		this.tableConfig = tableConfig;
		this.tableName = tableConfig.get("tableName").getAsString();
		this.objectName = tableConfig.has("objectName") ? tableConfig.get("objectName").getAsString() : "dbo";
		this.excelFilePath = tableConfig.get("excelFilePath").getAsString();
		this.sheetName = tableConfig.has("sheetName") ? tableConfig.get("sheetName").getAsString() : "Sheet1";
		this.headerRowIndex = tableConfig.has("headerRowIndex") ? tableConfig.get("headerRowIndex").getAsInt() : 0;
		this.createTableIfNotExists = !tableConfig.has("createTableIfNotExists")
				|| tableConfig.get("createTableIfNotExists").getAsBoolean();
		this.truncateBeforeInsert = tableConfig.has("truncateBeforeInsert")
				&& tableConfig.get("truncateBeforeInsert").getAsBoolean();
		this.insertMode = tableConfig.has("insertMode") ? tableConfig.get("insertMode").getAsString().toLowerCase()
				: "insert";
		this.updateStrategy = tableConfig.has("updateStrategy")
				? tableConfig.get("updateStrategy").getAsString().toLowerCase()
				: "all";
		
		this.uniqueKeys = new ArrayList<>();
		if (tableConfig.has("uniqueKey")) {
			JsonArray uniqueKeyArray = tableConfig.getAsJsonArray("uniqueKey");
			for (int i = 0; i < uniqueKeyArray.size(); i++) {
				uniqueKeys.add(uniqueKeyArray.get(i).getAsString());
			}
		}

		this.columns = new ArrayList<>();
		JsonArray columnsArray = tableConfig.getAsJsonArray("columns");
		for (int i = 0; i < columnsArray.size(); i++) {
			columns.add(new DatabaseHelper.ColumnInfo(columnsArray.get(i).getAsJsonObject()));
		}
	}

	public void process() throws Exception {
		File excelFile = new File(excelFilePath);
		if (!excelFile.exists()) {
			throw new IOException("Excel file not found: " + excelFilePath);
		}

		boolean tableExists = dbHelper.tableExists(tableName, objectName);
		
		if (!tableExists) {
			if (createTableIfNotExists) {
				dbHelper.createTable(tableName, objectName, columns);
			} else {
				throw new SQLException(
						"Table '" + objectName + "." + tableName + "' does not exist and auto-creation is disabled");
			}
		} else {
			System.out.println("Table '" + objectName + "." + tableName + "' already exists");

			if (truncateBeforeInsert) {
				dbHelper.truncateTable(tableName, objectName);
			}
		}
	
		// Read Excel data
		System.out.println("Reading Excel file: " + excelFilePath);
		List<Map<String, Object>> data = readExcel();

		if (data.isEmpty()) {
			System.out.println("WARNING: No data found in Excel file");
			return;
		}

		System.out.println("Found " + data.size() + " rows to process");

		// Insert data
		insertData(data);
	}

	private List<Map<String, Object>> readExcel() throws IOException {
		List<Map<String, Object>> data = new ArrayList<>();
		try (FileInputStream fis = new FileInputStream(excelFilePath)) {
			Workbook workbook;

			if (excelFilePath.toLowerCase().endsWith(".xlsx")) {
				workbook = new XSSFWorkbook(fis);
			} else if (excelFilePath.toLowerCase().endsWith(".xls")) {
				workbook = new HSSFWorkbook(fis);
			} else {
				throw new IllegalArgumentException("Unsupported file format. Use .xlsx or .xls");				
			}

			// Get sheet
			Sheet sheet;
			if (sheetName != null && !sheetName.trim().isEmpty()) {
				sheet = workbook.getSheet(sheetName);
				if (sheet == null) {
					System.err.println("WARNING: Sheet '" + sheetName + "' not found. Using first sheet.");
					sheet = workbook.getSheetAt(0);
				}
			} else {
				sheet = workbook.getSheetAt(0);
			}

			if (sheet.getPhysicalNumberOfRows() == 0) {
				workbook.close();
				return data;
			}

			// Build column letter to index map
			Map<String, Integer> letterToIndex = buildColumnMap();

			System.out.println("Header row index: " + headerRowIndex + " (this row will be skipped)");
			System.out.println("Reading data using Excel column letters: " + getColumnLettersList());

			// Read data rows - skip header row
			int dataStartRow = headerRowIndex + 1;
			for (int i = dataStartRow; i <= sheet.getLastRowNum(); i++) {
				Row row = sheet.getRow(i);
				if (row == null || isRowEmpty(row)) {
					continue;
				}

				Map<String, Object> rowData = new LinkedHashMap<>();

				for (DatabaseHelper.ColumnInfo column : columns) {
					Integer cellIndex = letterToIndex.get(column.getExcelColumnLetter().toUpperCase());
					if (cellIndex != null) {						
						Cell cell = row.getCell(cellIndex, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL);
						Object value = getCellValue(cell);
						rowData.put(column.getColumnName(), value);
					} else {
						rowData.put(column.getColumnName(), null);
					}
				}

				data.add(rowData);
			}
			workbook.close();
		}

		return data;
	}

	private String getColumnLettersList() {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < columns.size(); i++) {
			if (i > 0)
				sb.append(", ");
			sb.append(columns.get(i).getExcelColumnLetter());
		}
		return sb.toString();
	}

	private Map<String, Integer> buildColumnMap() {
		Map<String, Integer> map = new HashMap<>();
		for (DatabaseHelper.ColumnInfo column : columns) {
			String letter = column.getExcelColumnLetter().toUpperCase();
			int index = columnLetterToIndex(letter);
			map.put(letter, index);
		}
		return map;
	}

	private int columnLetterToIndex(String letter) {
		int index = 0;
		for (int i = 0; i < letter.length(); i++) {
			index = index * 26 + (letter.charAt(i) - 'A' + 1);
		}
		return index - 1;
	}

	private Object getCellValue(Cell cell) {
		if (cell == null) {
			return null;
		}
		switch (cell.getCellType()) {
		case STRING:
			String strValue = cell.getStringCellValue();
			return strValue.trim().isEmpty() ? null : strValue;

		case NUMERIC:
			if (DateUtil.isCellDateFormatted(cell)) {
				return cell.getDateCellValue();
			} else {
				double numValue = cell.getNumericCellValue();
				if (numValue == Math.floor(numValue)) {
					return (long) numValue;
				}
				return numValue;
			}

		case BOOLEAN:
			return cell.getBooleanCellValue();

		case FORMULA:
			try {
				return cell.getNumericCellValue();
			} catch (Exception e) {
				try {
					return cell.getStringCellValue();
				} catch (Exception ex) {
					return null;
				}
			}

		case BLANK:
			return null;

		default:
			return null;
		}
	}

	private boolean isRowEmpty(Row row) {
		for (int i = row.getFirstCellNum(); i < row.getLastCellNum(); i++) {
			Cell cell = row.getCell(i);
			if (cell != null && cell.getCellType() != CellType.BLANK) {
				Object value = getCellValue(cell);
				if (value != null && !value.toString().trim().isEmpty()) {
					return false;
				}
			}
		}
		return true;
	}
	
	private void insertData(List<Map<String, Object>> data) throws SQLException {
		String schema = (objectName != null && !objectName.isEmpty()) ? objectName : "dbo";

		if ("upsert".equals(insertMode)) {
			if (uniqueKeys.isEmpty()) {
				throw new SQLException("UPSERT mode requires 'uniqueKey' configuration");
			}
			System.out.println("Insert Mode: UPSERT (Update if exists, Insert if not)");
			System.out.println("Unique Key(s): " + String.join(", ", uniqueKeys));
			System.out.println("Update Strategy: " + updateStrategy.toUpperCase()
					+ " (all=update all columns, non-null=update only non-null values)");
		} else {
			System.out.println("Insert Mode: INSERT (Insert only)");
		}

		int totalRows = data.size();
		int insertedRows = 0;
		int updatedRows = 0;
		int failedRows = 0;

		Connection conn = dbHelper.getConnection();
		conn.setAutoCommit(false);

		try {
			if ("insert".equals(insertMode)) {
				int[] results = performInsert(conn, data, schema);
				insertedRows = results[0];
				failedRows = results[1];
			} else if ("upsert".equals(insertMode)) {
				int[] results = performUpsert(conn, data, schema);
				insertedRows = results[0];
				updatedRows = results[1];
				failedRows = results[2];
			}

			conn.commit();

		} catch (SQLException e) {
			conn.rollback();
			throw e;
		} finally {
			conn.setAutoCommit(true);
		}

		System.out.println("\n=== Insert Summary for " + tableName + " ===");
		System.out.println("Total rows: " + totalRows);
		if ("upsert".equals(insertMode)) {
			System.out.println("Inserted (new): " + insertedRows);
			System.out.println("Updated (existing): " + updatedRows);
			System.out.println("Failed: " + failedRows);
		} else {
			System.out.println("Successfully inserted: " + insertedRows);
			System.out.println("Failed: " + failedRows);
		}
	}

	private int[] performInsert(Connection conn, List<Map<String, Object>> data, String schema) throws SQLException {
		StringBuilder sql = new StringBuilder();
		sql.append("INSERT INTO [").append(schema).append("].[").append(tableName).append("] (");

		for (int i = 0; i < columns.size(); i++) {
			if (i > 0)
				sql.append(", ");
			sql.append("[").append(columns.get(i).getColumnName()).append("]");
		}

		sql.append(") VALUES (");

		for (int i = 0; i < columns.size(); i++) {
			if (i > 0)
				sql.append(", ");
			sql.append("?");
		}

		sql.append(")");

		int batchSize = dbHelper.getBatchSize();
		int totalRows = data.size();
		int insertedRows = 0;
		int failedRows = 0;
		int startIndex = 0;

		try (PreparedStatement pstmt = conn.prepareStatement(sql.toString())) {
			int batchCount = 0;

			for (int i = 0; i < totalRows; i++) {
				Map<String, Object> row = data.get(i);

				try {
					for (int j = 0; j < columns.size(); j++) {
						DatabaseHelper.ColumnInfo column = columns.get(j);
						Object value = row.get(column.getColumnName());
						column.setParameter(pstmt, j + 1, value);
					}

					pstmt.addBatch();
					batchCount++;

					if (batchCount >= batchSize || i == totalRows - 1) {
						try {
							int[] results = pstmt.executeBatch();
							
							for (int result : results) {
								if (result >= 0 || result == Statement.SUCCESS_NO_INFO) {
									insertedRows++;
								} else if (result == Statement.EXECUTE_FAILED) {
									failedRows++;
								}
							}
							
							batchCount = 0;
							startIndex = i + 1;
							
						} catch (BatchUpdateException bue) {
							// Handle batch failure
							int[] updateCounts = bue.getUpdateCounts();
							
							for (int k = 0; k < updateCounts.length; k++) {
								if (updateCounts[k] >= 0 || updateCounts[k] == Statement.SUCCESS_NO_INFO) {
									insertedRows++;
								} else if (updateCounts[k] == Statement.EXECUTE_FAILED) {
									failedRows++;
									System.err.println("Row " + (startIndex + k + 1) + " not inserted: " + data.get(startIndex + k));
								}
							}
							
							// Count remaining rows in failed batch
							int remainingInBatch = batchCount - updateCounts.length;
							failedRows += remainingInBatch;
							
							System.err.println("Batch execution error: " + bue.getMessage());
							batchCount = 0;
							startIndex = i + 1;
						}

						System.out.println("Progress: " + (i + 1) + "/" + totalRows + " rows processed");
					}

				} catch (SQLException e) {
					failedRows++;
					System.err.println("Error preparing row " + (i + 1) + ": " + e.getMessage());
					if (batchCount > 0) {
						batchCount--;
					}
				}
			}
		}

		return new int[] { insertedRows, failedRows };
	}

	private int[] performUpsert(Connection conn, List<Map<String, Object>> data, String schema) throws SQLException {
		int insertedRows = 0;
		int updatedRows = 0;
		int failedRows = 0;
		int totalRows = data.size();
		int batchSize = dbHelper.getBatchSize();

		// Build MERGE statement (SQL Server's native UPSERT)
		StringBuilder mergeSql = new StringBuilder();
		mergeSql.append("MERGE INTO [").append(schema).append("].[").append(tableName).append("] AS target ");
		mergeSql.append("USING (VALUES (");
		
		// Add placeholders for all columns
		for (int i = 0; i < columns.size(); i++) {
			if (i > 0) mergeSql.append(", ");
			mergeSql.append("?");
		}
		mergeSql.append(")) AS source (");
		
		// Add column names
		for (int i = 0; i < columns.size(); i++) {
			if (i > 0) mergeSql.append(", ");
			mergeSql.append("[").append(columns.get(i).getColumnName()).append("]");
		}
		mergeSql.append(") ON ");
		
		// Add ON clause with unique keys
		for (int i = 0; i < uniqueKeys.size(); i++) {
			if (i > 0) mergeSql.append(" AND ");
			mergeSql.append("target.[").append(uniqueKeys.get(i)).append("] = source.[").append(uniqueKeys.get(i)).append("]");
		}
		
		// Build UPDATE clause
		mergeSql.append(" WHEN MATCHED THEN UPDATE SET ");
		int updateColCount = 0;
		for (DatabaseHelper.ColumnInfo column : columns) {
			if (!uniqueKeys.contains(column.getColumnName())) {
				if (updateColCount > 0) mergeSql.append(", ");
				
				if ("non-null".equals(updateStrategy)) {
					// Only update if source value is not null
					mergeSql.append("target.[").append(column.getColumnName()).append("] = ")
						   .append("CASE WHEN source.[").append(column.getColumnName()).append("] IS NOT NULL ")
						   .append("THEN source.[").append(column.getColumnName()).append("] ")
						   .append("ELSE target.[").append(column.getColumnName()).append("] END");
				} else {
					// Update all (including nulls)
					mergeSql.append("target.[").append(column.getColumnName()).append("] = source.[")
						   .append(column.getColumnName()).append("]");
				}
				updateColCount++;
			}
		}
		
		// Build INSERT clause
		mergeSql.append(" WHEN NOT MATCHED THEN INSERT (");
		for (int i = 0; i < columns.size(); i++) {
			if (i > 0) mergeSql.append(", ");
			mergeSql.append("[").append(columns.get(i).getColumnName()).append("]");
		}
		mergeSql.append(") VALUES (");
		for (int i = 0; i < columns.size(); i++) {
			if (i > 0) mergeSql.append(", ");
			mergeSql.append("source.[").append(columns.get(i).getColumnName()).append("]");
		}
		mergeSql.append(") OUTPUT $action;");

		System.out.println("Using MERGE statement for batch UPSERT operations");

		try (PreparedStatement mergeStmt = conn.prepareStatement(mergeSql.toString())) {
			int batchCount = 0;
			int startIndex = 0;

			for (int i = 0; i < totalRows; i++) {
				Map<String, Object> row = data.get(i);

				try {
					// Validate NOT NULL columns before adding to batch
					if (!validateNotNullColumns(row)) {
						failedRows++;
						System.err.println("Row " + (i + 1) + ": Skipped - NOT NULL column(s) have null values");
						continue;
					}

					// Set parameters for all columns
					for (int j = 0; j < columns.size(); j++) {
						DatabaseHelper.ColumnInfo column = columns.get(j);
						Object value = row.get(column.getColumnName());
						column.setParameter(mergeStmt, j + 1, value);
					}

					mergeStmt.addBatch();
					batchCount++;

					// Execute batch when size is reached or at the end
					if (batchCount >= batchSize || i == totalRows - 1) {
						try {
							int[] results = mergeStmt.executeBatch();
							
							// Process results - MERGE with OUTPUT returns result set, not update counts
							// We need to count the actions differently
							for (int result : results) {
								if (result > 0) {
									// Since we can't distinguish INSERT vs UPDATE from update count alone
									// with OUTPUT $action, we'll count all successes
									// A better approach would be to use a different query or parse OUTPUT
									insertedRows++; // This is a simplification
								} else if (result == Statement.EXECUTE_FAILED) {
									failedRows++;
								}
							}
							
							batchCount = 0;
							startIndex = i + 1;
							
						} catch (BatchUpdateException bue) {
							// Handle batch failure
							int[] updateCounts = bue.getUpdateCounts();
							
							for (int k = 0; k < updateCounts.length; k++) {
								if (updateCounts[k] > 0 || updateCounts[k] == Statement.SUCCESS_NO_INFO) {
									insertedRows++;
								} else if (updateCounts[k] == Statement.EXECUTE_FAILED) {
									failedRows++;
									System.err.println("Row " + (startIndex + k + 1) + " failed: " + data.get(startIndex + k));
								}
							}
							
							// Count remaining rows in failed batch
							int remainingInBatch = batchCount - updateCounts.length;
							failedRows += remainingInBatch;
							
							System.err.println("Batch execution error at row " + (startIndex + 1) + ": " + bue.getMessage());
							batchCount = 0;
							startIndex = i + 1;
						}

						System.out.println("Progress: " + (i + 1) + "/" + totalRows + " rows processed");
					}

				} catch (SQLException e) {
					failedRows++;
					System.err.println("Error preparing row " + (i + 1) + ": " + e.getMessage());
					if (batchCount > 0) {
						batchCount--;
					}
				}
			}
		}

		// Note: With simple MERGE, we count all successful operations as "inserted"
		// To properly distinguish INSERT vs UPDATE, we'd need to capture OUTPUT $action
		// For now, report all as "upserted" by putting count in insertedRows
		return new int[] { insertedRows, 0, failedRows };
	}

	private boolean validateNotNullColumns(Map<String, Object> row) {
		for (DatabaseHelper.ColumnInfo column : columns) {
			if (!column.isNullable()) {
				Object value = row.get(column.getColumnName());
				if (value == null) {
					System.err.println("Validation failed: Column '" + column.getColumnName()
							+ "' is NOT NULL but has null value");
					return false;
				}
			}
		}
		return true;
	}

	private DatabaseHelper.ColumnInfo getColumnByName(String columnName) {
		for (DatabaseHelper.ColumnInfo column : columns) {
			if (column.getColumnName().equals(columnName)) {
				return column;
			}
		}
		return null;
	}
}




























private int[] performUpsert(Connection conn, List<Map<String, Object>> data, String schema) throws SQLException {
    int insertedRows = 0;
    int updatedRows = 0;
    int failedRows = 0;
    int totalRows = data.size();
    int batchSize = dbHelper.getBatchSize();

    // Build MERGE statement (SQL Server's native UPSERT)
    StringBuilder mergeSql = new StringBuilder();
    mergeSql.append("MERGE INTO [").append(schema).append("].[").append(tableName).append("] AS target ");
    mergeSql.append("USING (VALUES (");
    
    // Add placeholders for all columns
    for (int i = 0; i < columns.size(); i++) {
        if (i > 0) mergeSql.append(", ");
        mergeSql.append("?");
    }
    mergeSql.append(")) AS source (");
    
    // Add column names
    for (int i = 0; i < columns.size(); i++) {
        if (i > 0) mergeSql.append(", ");
        mergeSql.append("[").append(columns.get(i).getColumnName()).append("]");
    }
    mergeSql.append(") ON ");
    
    // Add ON clause with unique keys
    for (int i = 0; i < uniqueKeys.size(); i++) {
        if (i > 0) mergeSql.append(" AND ");
        mergeSql.append("target.[").append(uniqueKeys.get(i)).append("] = source.[").append(uniqueKeys.get(i)).append("]");
    }
    
    // Build UPDATE clause
    mergeSql.append(" WHEN MATCHED THEN UPDATE SET ");
    int updateColCount = 0;
    for (DatabaseHelper.ColumnInfo column : columns) {
        if (!uniqueKeys.contains(column.getColumnName())) {
            if (updateColCount > 0) mergeSql.append(", ");
            
            if ("non-null".equals(updateStrategy)) {
                // Only update if source value is not null
                mergeSql.append("target.[").append(column.getColumnName()).append("] = ")
                       .append("CASE WHEN source.[").append(column.getColumnName()).append("] IS NOT NULL ")
                       .append("THEN source.[").append(column.getColumnName()).append("] ")
                       .append("ELSE target.[").append(column.getColumnName()).append("] END");
            } else {
                // Update all (including nulls)
                mergeSql.append("target.[").append(column.getColumnName()).append("] = source.[")
                       .append(column.getColumnName()).append("]");
            }
            updateColCount++;
        }
    }
    
    // Build INSERT clause
    mergeSql.append(" WHEN NOT MATCHED THEN INSERT (");
    for (int i = 0; i < columns.size(); i++) {
        if (i > 0) mergeSql.append(", ");
        mergeSql.append("[").append(columns.get(i).getColumnName()).append("]");
    }
    mergeSql.append(") VALUES (");
    for (int i = 0; i < columns.size(); i++) {
        if (i > 0) mergeSql.append(", ");
        mergeSql.append("source.[").append(columns.get(i).getColumnName()).append("]");
    }
    mergeSql.append(") OUTPUT $action;");

    System.out.println("Using MERGE statement for batch UPSERT operations");

    try (PreparedStatement mergeStmt = conn.prepareStatement(mergeSql.toString())) {
        int batchCount = 0;
        int startIndex = 0;

        for (int i = 0; i < totalRows; i++) {
            Map<String, Object> row = data.get(i);

            try {
                // Validate NOT NULL columns before adding to batch
                if (!validateNotNullColumns(row)) {
                    failedRows++;
                    System.err.println("Row " + (i + 1) + ": Skipped - NOT NULL column(s) have null values");
                    continue;
                }

                // Set parameters for all columns
                for (int j = 0; j < columns.size(); j++) {
                    DatabaseHelper.ColumnInfo column = columns.get(j);
                    Object value = row.get(column.getColumnName());
                    column.setParameter(mergeStmt, j + 1, value);
                }

                mergeStmt.addBatch();
                batchCount++;

                // Execute batch when size is reached or at the end
                if (batchCount >= batchSize || i == totalRows - 1) {
                    try {
                        int[] results = mergeStmt.executeBatch();
                        
                        // MERGE returns 1 for INSERT, 2 for UPDATE
                        for (int result : results) {
                            if (result == 1 || result == Statement.SUCCESS_NO_INFO) {
                                insertedRows++;
                            } else if (result == 2) {
                                updatedRows++;
                            } else if (result == Statement.EXECUTE_FAILED) {
                                failedRows++;
                            }
                        }
                        
                        batchCount = 0;
                        startIndex = i + 1;
                        
                    } catch (BatchUpdateException bue) {
                        // Handle batch failure
                        int[] updateCounts = bue.getUpdateCounts();
                        
                        for (int k = 0; k < updateCounts.length; k++) {
                            if (updateCounts[k] == 1 || updateCounts[k] == Statement.SUCCESS_NO_INFO) {
                                insertedRows++;
                            } else if (updateCounts[k] == 2) {
                                updatedRows++;
                            } else if (updateCounts[k] == Statement.EXECUTE_FAILED) {
                                failedRows++;
                                System.err.println("Row " + (startIndex + k + 1) + " failed: " + data.get(startIndex + k));
                            }
                        }
                        
                        // Count remaining rows in failed batch
                        int remainingInBatch = batchCount - updateCounts.length;
                        failedRows += remainingInBatch;
                        
                        System.err.println("Batch execution error at row " + (startIndex + 1) + ": " + bue.getMessage());
                        batchCount = 0;
                        startIndex = i + 1;
                    }

                    System.out.println("Progress: " + (i + 1) + "/" + totalRows + " rows processed");
                }

            } catch (SQLException e) {
                failedRows++;
                System.err.println("Error preparing row " + (i + 1) + ": " + e.getMessage());
                if (batchCount > 0) {
                    batchCount--;
                }
            }
        }
    }

    return new int[] { insertedRows, updatedRows, failedRows };
}
